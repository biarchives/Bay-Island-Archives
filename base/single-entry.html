<a href="archives.html" class="back-link">‚Üê To All Archives</a>

<div class="entry-main single-entry-main">
  <div class="entry-header">
    <div class='entry-text-block'>
      <h1 class="entry-title" id="entry-title"></h1>
      <p class="entry-meta" id="entry-meta"></p>
      <div class="entry-description" id="entry-description"></div>
    </div>
  </div>
  <div id="single-media-placeholder"></div>
</div>

<div id="related-links-placeholder"></div>

<script>
  window.addEventListener('load', () => {
    window.scrollTo(0, 0);
  });

  // Ensure spaceId and accessToken are defined, as they are used in the URL.
  // The code assumes they are globally available.
  const contentfulUrl = `https://cdn.contentful.com/spaces/${spaceId}/environments/master/entries?access_token=${accessToken}&sys.id=${entryId}&include=2`;

  fetch(contentfulUrl)
    .then(res => res.json())
    .then(data => {
      const entry = data.items[0];
      const fields = entry.fields;
      const includes = data.includes;

      document.title = `${fields.title || 'Untitled'} | Bay Islands Archives`;

      // Helper function to resolve assets and entries
      const assetsMap = {};
      includes?.Asset?.forEach(asset => {
        if (asset.sys.id && asset.fields?.file?.url) {
          assetsMap[asset.sys.id] = {
            url: `https:${asset.fields.file.url}`,
            description: asset.fields.description || '',
            contentType: asset.fields.file.contentType
          };
        }
      });

      const relatedEntriesMap = {};
      includes?.Entry?.forEach(e => {
        relatedEntriesMap[e.sys.id] = e;
      });

      // Populate main content
      document.getElementById('entry-title').textContent = fields.title || 'Untitled';
      const date = fields.date ? new Date(fields.date).getFullYear() : 'Unknown Year';
      // A reusable function to resolve locations
      function resolveLocationAndIsland(entry) {
        let locationsData = [];
        const locationRefs = entry.fields.location;
        const locationsArray = Array.isArray(locationRefs) ? locationRefs : (locationRefs ? [locationRefs] : []);

        locationsArray.forEach(locationRef => {
          const locationEntry = relatedEntriesMap[locationRef.sys.id];
          if (locationEntry?.fields) {
            let locationName = 'Unknown Location';
            let islandName = 'Unknown Island';

            const islandRef = locationEntry.fields.island;
            if (islandRef?.sys?.id) {
              const islandEntry = relatedEntriesMap[islandRef.sys.id];
              islandName = islandEntry?.fields?.island || 'Unknown Island';
            }

            if (locationEntry.fields.geolocation) {
              locationName = locationEntry.fields.geolocation;
            } else {
              locationName = islandName;
            }

            locationsData.push({ locationName, islandName });
          }
        });

        if (locationsData.length === 0) {
          locationsData.push({ locationName: 'Unknown Location', islandName: '' });
        }
        return locationsData;
      }

      const locationsData = resolveLocationAndIsland(entry);
      const formattedLocations = locationsData.map(loc => {
        if (loc.locationName && loc.islandName && loc.locationName !== loc.islandName) {
          return `${loc.locationName}, ${loc.islandName}`;
        }
        return loc.locationName;
      }).join('; ');

      document.getElementById('entry-meta').innerHTML = `${formattedLocations}<br>${date}`;

      if (fields.description?.content?.[0]?.content?.[0]?.value) {
        document.getElementById('entry-description').textContent = fields.description.content[0].content[0].value;
      }

      // Helper function for YouTube ID extraction
      function extractYouTubeVideoId(url) {
        if (!url) return null;
        const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
        const match = url.match(regex);
        return (match && match[1]) ? match[1] : null;
      }

      // Single Media Handling
      const mediaPlaceholder = document.getElementById('single-media-placeholder');
      let mediaHtml = `<img src="https://placehold.co/600x400?text=No+Media" alt="No media available" />`;

      const mediaField = entry.fields.media;
      const videoEmbedUrl = fields.videoEmbedUrl;

      if (mediaField && mediaField.sys?.id) {
        const mediaAsset = assetsMap[mediaField.sys.id];

        if (mediaAsset) {
          const url = mediaAsset.url;
          const type = mediaAsset.contentType;

          if (type.startsWith('image/')) {
            mediaHtml = `<img src="${url}" alt="${mediaAsset.description || 'Media file'}" class="single-media-file" />`;
          } else if (type.startsWith('video/')) {
            mediaHtml = `
              <div class="video-wrapper">
                <video controls class="single-media-file">
                  <source src="${url}" type="${type}">
                  Your browser does not support the video tag.
                </video>
              </div>`;
          } else if (type.startsWith('audio/')) {
            mediaHtml = `
              <audio controls class="single-media-file">
                <source src="${url}" type="${type}">
                Your browser does not support the audio element.
              </audio>`;
          }
        }
      } else if (videoEmbedUrl) {
        const videoId = extractYouTubeVideoId(videoEmbedUrl);
        if (videoId) {
          // Use the correct YouTube embed URL
          const embedUrl = `https://www.youtube.com/embed/${videoId}`;
          mediaHtml = `<div class="video-wrapper"><iframe src="${embedUrl}" frameborder="0" allowfullscreen></iframe></div>`;
        } else {
          // Fallback for non-YouTube links
          mediaHtml = `<a href="${videoEmbedUrl}" target="_blank">External Link</a>`;
        }
      }

      mediaPlaceholder.innerHTML = mediaHtml;
      // Related Links (you would add similar logic here)

    })
    .catch(err => console.error('Error fetching single entry:', err));
</script>
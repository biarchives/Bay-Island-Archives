<a href="archives.html" class="back-link">← To All Archives</a>

<div class="entry-main single-entry-main">
  <div class="entry-header">
    <div class='entry-text-block'>
      <h1 class="entry-title" id="entry-title"></h1>
      <p class="entry-meta" id="entry-meta"></p>
      <div class="entry-description" id="entry-description"></div>
    </div>
  </div>
  <div id="single-media-placeholder"></div>
</div>

<div id="related-links-placeholder"></div>

<div class="fullscreen-overlay" id="fullscreen-overlay">
  <div class="fullscreen-modal">
    <button class="fullscreen-close" id="fullscreen-close">×</button>
    <img src="" alt="Fullscreen Image" id="fullscreen-image" />
    <p class="fullscreen-caption" id="fullscreen-caption"></p>
  </div>
</div>

<script>
  window.addEventListener('load', () => {
    window.scrollTo(0, 0);
  });

  const contentfulUrl = `https://cdn.contentful.com/spaces/${spaceId}/environments/master/entries?access_token=${accessToken}&sys.id=${entryId}&include=2`;

  fetch(contentfulUrl)
    .then(res => res.json())
    .then(data => {
      const entry = data.items[0];
      const fields = entry.fields;
      const includes = data.includes;

      document.title = `${fields.title || 'Untitled'} | Bay Islands Archives`;

      const assetsMap = {};
      includes?.Asset?.forEach(asset => {
        if (asset.sys.id && asset.fields?.file?.url) {
          assetsMap[asset.sys.id] = {
            url: `https:${asset.fields.file.url}`,
            description: asset.fields.description || '',
            contentType: asset.fields.file.contentType
          };
        }
      });

      const relatedEntriesMap = {};
      includes?.Entry?.forEach(e => {
        relatedEntriesMap[e.sys.id] = e;
      });

      // Populate main content
      document.getElementById('entry-title').textContent = fields.title || 'Untitled';
      const date = fields.date ? new Date(fields.date).getFullYear() : 'Unknown Year';

      function resolveLocationAndIsland(entry) {
        let locationsData = [];
        const locationRefs = entry.fields.location;
        const locationsArray = Array.isArray(locationRefs) ? locationRefs : (locationRefs ? [locationRefs] : []);

        locationsArray.forEach(locationRef => {
          const locationEntry = relatedEntriesMap[locationRef.sys.id];
          if (locationEntry?.fields) {
            const contentTypeId = locationEntry.sys.contentType.sys.id;
            let locationName = 'Unknown Location';
            let islandName = 'Unknown Island';

            if (contentTypeId === 'geolocation') {
              const islandRef = locationEntry.fields.island;
              if (islandRef?.sys?.id) {
                const islandEntry = relatedEntriesMap[islandRef.sys.id];
                islandName = islandEntry?.fields?.island || 'Unknown Island';
              }
              if (locationEntry.fields.geolocation) {
                locationName = locationEntry.fields.geolocation;
              } else {
                locationName = islandName;
              }
              locationsData.push({
                locationName,
                islandName
              });
            } else if (contentTypeId === 'island') {
              islandName = locationEntry.fields.island || 'Unknown Island';
              locationsData.push({
                locationName: islandName,
                islandName: islandName
              });
            }
          }
        });

        if (locationsData.length === 0) {
          locationsData.push({
            locationName: 'Unknown Location',
            islandName: ''
          });
        }
        return locationsData;
      }

      const locationsData = resolveLocationAndIsland(entry);
      const formattedLocations = locationsData.map(loc => {
        if (loc.locationName !== loc.islandName && loc.locationName !== 'Unknown Location') {
          return `${loc.locationName}, ${loc.islandName}`;
        }
        return loc.locationName;
      }).join(' & ');

      document.getElementById('entry-meta').innerHTML = `${formattedLocations}<br>${date}`;
      if (fields.description?.content?.[0]?.content?.[0]?.value) {
        document.getElementById('entry-description').textContent = fields.description.content[0].content[0].value;
      }

      function extractYouTubeVideoId(url) {
        if (!url) return null;
        const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
        const match = url.match(regex);
        return (match && match[1]) ? match[1] : null;
      }

      const mediaPlaceholder = document.getElementById('single-media-placeholder');
      let mediaHtml = '';
      let mediaAssetUrl = '';
      let mediaAssetDescription = '';
      let isImage = false;

      const mediaField = entry.fields.media;
      const videoEmbedUrl = fields.videoEmbedUrl;

      if (mediaField && mediaField.sys?.id) {
        const mediaAsset = assetsMap[mediaField.sys.id];

        if (mediaAsset) {
          mediaAssetUrl = mediaAsset.url;
          mediaAssetDescription = mediaAsset.description || '';
          const type = mediaAsset.contentType;

          if (type.startsWith('image/')) {
            isImage = true;
            mediaHtml = `<img src="${mediaAssetUrl}" alt="${mediaAssetDescription}" class="single-media-file" id="single-image-to-fullscreen" />`;
          } else if (type.startsWith('video/')) {
            mediaHtml = `
              <div class="video-wrapper">
                <video controls class="single-media-file">
                  <source src="${mediaAssetUrl}" type="${type}">
                  Your browser does not support the video tag.
                </video>
              </div>`;
          } else if (type.startsWith('audio/')) {
            mediaHtml = `
              <audio controls class="single-media-file">
                <source src="${mediaAssetUrl}" type="${type}">
                Your browser does not support the audio element.
              </audio>`;
          } else if (type === 'application/pdf') {
            mediaHtml = `
              <div class="pdf-wrapper">
                <iframe src="${mediaAssetUrl}#toolbar=0" class="pdf-frame"></iframe>
              </div>`;
          }
        }
      } else if (videoEmbedUrl) {
        const videoId = extractYouTubeVideoId(videoEmbedUrl);
        if (videoId) {
          const embedUrl = `https://www.youtube.com/embed/${videoId}`;
          mediaHtml = `<div class="video-wrapper"><iframe src="${embedUrl}" frameborder="0" allowfullscreen></iframe></div>`;
        } else {
          mediaHtml = `<a href="${videoEmbedUrl}" target="_blank">External Link</a>`;
        }
      } else {
        mediaHtml = `<img src="https://placehold.co/600x400?text=No+Media" alt="No media available" />`;
      }

      mediaPlaceholder.innerHTML = mediaHtml;

      // --- FULLSCREEN LOGIC for a single image ---
      if (isImage) {
        const fullscreenOverlay = document.getElementById('fullscreen-overlay');
        const fullscreenImage = document.getElementById('fullscreen-image');
        const fullscreenCaption = document.getElementById('fullscreen-caption');
        const singleImageElement = document.getElementById('single-image-to-fullscreen');

        if (singleImageElement) {
          singleImageElement.addEventListener('click', () => {
            fullscreenImage.src = mediaAssetUrl;
            fullscreenImage.alt = mediaAssetDescription;
            fullscreenCaption.textContent = mediaAssetDescription;
            fullscreenOverlay.classList.add('visible');
            document.body.style.overflow = 'hidden';
          });
        }

        fullscreenOverlay.addEventListener('click', (e) => {
          if (e.target.id === 'fullscreen-close' || e.target.classList.contains('fullscreen-overlay')) {
            fullscreenOverlay.classList.remove('visible');
            document.body.style.overflow = '';
          }
        });
      }
    })
    .catch(err => console.error('Error fetching single entry:', err));
</script>